---
title: NuGet V3 API のカタログ リソース
description: カタログは、すべてのパッケージの作成および nuget.org に削除されたインデックスです。
author: joelverhagen
ms.author: jver
manager: skofman
ms.date: 10/30/2017
ms.topic: reference
ms.reviewer: kraigb
ms.openlocfilehash: 464b252ca318a5bd3487c723dbf4c7062e4698a3
ms.sourcegitcommit: 3eab9c4dd41ea7ccd2c28bb5ab16f6fbbec13708
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/26/2018
---
# <a name="catalog"></a>Catalog

**カタログ**リソースの作成と削除など、パッケージ ソースのすべてのパッケージ操作の記録です。 カタログ リソースは、`Catalog`に入力、[サービス インデックス](service-index.md)です。

> [!Note]
> カタログが使用されないため、公式の NuGet クライアントによって、すべてのパッケージ ソースはカタログを実装します。

> [!Note]
> 現在、nuget.org カタログでは、中国で使用できません。 詳細については、次を参照してください。 [NuGet/NuGetGallery #4949](https://github.com/NuGet/NuGetGallery/issues/4949)です。

## <a name="versioning"></a>バージョン管理

次`@type`値を使用します。

@type の値   | メモ
------------- | -----
Catalog/3.0.0 | 最初のリリース

## <a name="base-url"></a>[基本 URL]

値は、以下の api エントリ ポイントの URL、`@id`前述のリソースに関連付けられたプロパティ`@type`値。 このトピックはプレース ホルダー URL を使用して`{@id}`です。

## <a name="http-methods"></a>HTTP メソッド

HTTP メソッドのみをカタログ リソースのサポートで見つかったすべての Url`GET`と`HEAD`です。

## <a name="catalog-index"></a>カタログのインデックス

カタログのインデックスは、時系列順に並べ、カタログ アイテムのリストを持つ既知の場所でドキュメントです。 これは、カタログ リソースのエントリ ポイントです。

インデックスは、カタログのページで構成されます。 カタログの各ページには、カタログ アイテムが含まれています。 各カタログ項目は、時間の時点で 1 つのパッケージに関連するイベントを表します。 カタログ項目は、作成した一覧にない、再度リストされます、または削除されたパッケージ ソースからパッケージを表すことができます。 時間においてこの順でカタログ アイテムを処理することで、クライアントは、V3 パッケージ ソースに存在するすべてのパッケージの最新の状態のビューを構築できます。

つまり、カタログの blob には、次の階層構造があります。

- **インデックス**: カタログのエントリ ポイントです。
- **ページ**: カタログ アイテムのグループ化します。
- **リーフ**: 1 つのパッケージの状態のスナップショットであるカタログ アイテムを表すドキュメント。

各カタログ オブジェクトと呼ばれるプロパティがあります、`commitTimeStamp`アイテムがカタログに追加されたときに表すです。 カタログ項目は、コミットを呼び出すバッチ内のカタログ ページに追加されます。 同じコミット内のすべてのカタログ項目が同じコミット タイムスタンプがある (`commitTimeStamp`) とコミット ID (`commitId`)。 カタログ項目が、同じコミット内に配置では、パッケージ ソースで同じポイントを中心に発生したイベントを表します。 カタログ コミット内で順序がありません。

各パッケージ ID とバージョンは、一意であるためにされませんカタログ アイテムを複数のコミットをします。 これにより、1 つのパッケージ用のカタログ アイテムが常に明確を並べ替えることのコミット タイムスタンプに関してされます。

カタログごとに 1 つ以上のコミットになることはありません`commitTimeStamp`です。 言い換えると、`commitId`で冗長、`commitTimeStamp`です。

対照的に、[パッケージ メタデータ リソース](registration-base-url-resource.md)、パッケージ ID、インデックス、カタログ、インデックスが (クエリ可能な) 時間によってのみです。

カタログ アイテムは常に、単調に増加する、時間においてこの順序で、カタログに追加します。 つまり、こと時 X カタログ コミットが追加された場合は、カタログのコミットがこれまで追加されません X 以下の時刻を使用します。

次の要求は、カタログのインデックスをフェッチします。

    GET {@id}

カタログのインデックスは、次のプロパティを持つオブジェクトを格納する JSON ドキュメントを示します。

名前            | 種類             | 必須 | メモ
--------------- | ---------------- | -------- | -----
commitId        | string           | 可      | 最新のコミットに関連付けられている一意の ID
commitTimeStamp | string           | 可      | 最新のコミットのタイムスタンプ
count           | 整数          | 可      | インデックスのページの数
項目           | オブジェクトの配列 | 可      | 各オブジェクト、ページを表す、オブジェクトの配列

内の各要素、`items`配列は、各ページに関するいくつかの最小限の情報を持つオブジェクト。 これらのページ オブジェクトでは、カタログ リーフ (アイテム) は含まれません。 この配列内の要素の順序が定義されていません。 ページの順序でメモリを使用してクライアントを指定できます、`commitTimeStamp`プロパティです。

新しいページが導入されていると、`count`は増加し、新しいオブジェクトに表示されます、`items`配列。

カタログ、インデックスの項目が追加されると`commitId`は変更され、`commitTimeStamp`が増加します。 これら 2 つのプロパティすべてのページで概要では基本的には、`commitId`と`commitTimeStamp`の値が、`items`配列。

### <a name="catalog-page-object-in-the-index"></a>インデックス内のカタログ ページ オブジェクト

カタログのインデックスのカタログ ページ オブジェクトが見つかりませんでした`items`プロパティがある、次のプロパティ。

名前            | 種類    | 必須 | メモ
--------------- | ------- | -------- | -----
@id             | string  | 可      | フェッチのカタログ ページの URL
commitId        | string  | 可      | このページで、最新のコミットに関連付けられている一意の ID
commitTimeStamp | string  | 可      | このページで、最新のコミットのタイムスタンプ
count           | 整数 | 可      | カタログ ページ内の項目数

対照的に、[パッケージ メタデータ リソース](registration-base-url-resource.md)、インデックスへのままにするいくつかの場合、インライン、カタログのリーフ インデックスにインライン展開されていることはありませんし、ページを使用して常にフェッチする必要があります`@id`URL。

### <a name="sample-request"></a>要求のサンプル

    GET https://api.nuget.org/v3/catalog0/index.json

### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-index.json](./_data/catalog-index.json)]

## <a name="catalog-page"></a>カタログ ページ

カタログ ページは、カタログ アイテムのコレクションです。 フェッチのいずれかを使用してドキュメントでは、`@id`カタログのインデックスに値が見つかりました。 カタログ ページの URL は、予測できるものではありませんし、カタログのインデックスのみを使用して検出する必要があります。

新しいカタログ アイテムは、最高のコミット タイムスタンプでのみカタログのインデックスのページに、または新しいページに追加されます。 コミット タイムスタンプが上位のページがカタログに追加されると、古いページが決してを追加または変更します。

カタログのページのドキュメントは、次のプロパティを使用して、JSON オブジェクトを示します。

名前            | 種類             | 必須 | メモ
--------------- | ---------------- | -------- | -----
commitId        | string           | 可      | このページで、最新のコミットに関連付けられている一意の ID
commitTimeStamp | string           | 可      | このページで、最新のコミットのタイムスタンプ
count           | 整数          | 可      | ページ内の項目数
項目           | オブジェクトの配列 | 可      | このページでカタログ アイテム
親          | string           | 可      | カタログのインデックスへの URL

内の各要素、`items`配列は、カタログ アイテムについての詳細を最小限に抑えるを持つオブジェクト。 これらの項目オブジェクトでは、すべてのカタログ アイテムのデータは含まれません。 ページの内の項目の順序`items`配列が定義されていません。 項目の順序でメモリを使用してクライアントを指定できます、`commitTimeStamp`プロパティです。

ページでカタログ アイテムの数は、サーバーの実装によって定義されます。 Nuget.org の多くて 550 項目は、各ページが、実際の数は、時間の時点で、次のコミット バッチのサイズによっては一部のページの小さい可能性があります。

新しい項目が導入されていると、`count`でインクリメントと新しいカタログ アイテムのオブジェクトの表示は、`items`配列。

項目が、ページに追加されるにつれて、`commitId`変更と`commitTimeStamp`が増加します。 これら 2 つのプロパティすべてに対する概要では基本的には、`commitId`と`commitTimeStamp`の値が、`items`配列。

### <a name="catalog-item-object-in-a-page"></a>カタログのページで項目オブジェクト

カタログ] ページの [カタログ アイテムのオブジェクトが見つかった`items`プロパティがある、次のプロパティ。

名前            | 種類    | 必須 | メモ
--------------- | ------- | -------- | -----
@id             | string  | 可      | カタログ アイテムをフェッチする URL
@type           | string  | 可      | カタログ項目の種類
commitId        | string  | 可      | このカタログ アイテムに関連付けられたコミット ID
commitTimeStamp | string  | 可      | このカタログ アイテムのコミット タイムスタンプ
nuget:id        | string  | 可      | このリーフに関連するパッケージ ID
nuget:version   | string  | 可      | このリーフに関連するパッケージのバージョン

`@type`値には、次の 2 つの値のいずれかになります。

1. `nuget:PackageDetails`: これに対応して`PackageDetails`カタログ リーフ ドキュメント内の型。
1. `nuget:PackageDelete`: これに対応して、`PackageDelete`カタログ リーフ ドキュメント内の型。

詳細については、各種類の意味を参照してください、[項目の種類を対応する](#item-types)以下です。

### <a name="sample-request"></a>要求のサンプル

    GET https://api.nuget.org/v3/catalog0/page2926.json

### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-page.json](./_data/catalog-page.json)]

## <a name="catalog-leaf"></a>リーフをカタログします。

カタログのリーフには、時間内の特定のパッケージ ID といくつかの時点のバージョンに関するメタデータが含まれています。 フェッチを使用してドキュメントでは、`@id`カタログ ページで値が見つかりました。 カタログ リーフへの URL は、予測できるものではありませんし、カタログ ページのみを使用して検出する必要があります。

カタログ リーフ ドキュメントでは、次のプロパティを使用して、JSON オブジェクトを示します。

名前                    | 種類                       | 必須 | メモ
----------------------- | -------------------------- | -------- | -----
@type                   | 文字列または文字列の配列 | 可      | カタログ アイテムの種類
catalog:commitId        | string                     | 可      | このカタログ アイテムに関連付けられたコミット ID
catalog:commitTimeStamp | string                     | 可      | このカタログ アイテムのコミット タイムスタンプ
ID                      | string                     | 可      | カタログ アイテムのパッケージ ID
発行               | string                     | 可      | パッケージのカタログ アイテムのパブリッシュされた日付
version                 | string                     | 可      | カタログ アイテムのパッケージのバージョン

### <a name="item-types"></a>項目の種類

`@type`プロパティは、文字列または文字列の配列。 便宜上場合、`@type`値は、文字列、サイズが 1 の任意の配列として扱う必要があります。 すべての可能な値`@type`は記載されています。 ただし、各カタログ アイテムには、次の 2 つの文字列型値の 1 つだけがあります。

1. `PackageDetails`: パッケージのメタデータのスナップショットを表します
1. `PackageDelete`: 削除されたパッケージを表します

### <a name="package-details-catalog-items"></a>カタログ アイテムをパッケージの詳細

カタログ アイテムの種類に`PackageDetails`(ID とバージョンの組み合わせ) の特定のパッケージのパッケージ メタデータのスナップショットが含まれています。 パッケージ ソースでは、次のシナリオのいずれかが発生したときに、パッケージの詳細のカタログ項目が生成されます。

1. パッケージは**プッシュ**です。
1. パッケージは**表示**です。
1. パッケージは**一覧にない**です。
1. パッケージは**折り返す**です。

パッケージのフロー変更は、管理ジェスチャ本質的には、パッケージ自体を変更せずに既存のパッケージの偽のプッシュを生成します。 Nuget.org、カタログを消費するバック グラウンド ジョブのいずれかでバグを修正した後、折り返しが使用されます。

クライアントのカタログ アイテムを使用しようとしないでください、カタログ アイテムを生成すると、これらのシナリオを決定します。 代わりに、クライアント必要があります単に保持しているビューまたは更新インデックス、カタログ アイテムに含まれるメタデータ。 重複するカタログ アイテムを効率よく処理する必要がありますさらに、(冪等)。

パッケージの詳細のカタログ アイテムに加え、次のプロパティがある[カタログのすべてのリーフに含まれている](#catalog-leaf)です。

名前                    | 種類                       | 必須 | メモ
----------------------- | -------------------------- | -------- | -----
作成者                 | string                     | Ｘ       |
created                 | string                     | 可      | パッケージが最初に作成されたときのタイムスタンプ
dependencyGroups        | オブジェクトの配列           | Ｘ       | 同じ形式、[メタデータ リソースをパッケージ化](registration-base-url-resource.md#package-dependency-group)
説明             | string                     | Ｘ       |
iconUrl                 | string                     | Ｘ       |
isPrerelease            | boolean                    | 可      | パッケージのバージョンがプレリリース版かどうか
language                | string                     | Ｘ       |
licenseUrl              | string                     | Ｘ       |
一覧                  | boolean                    | Ｘ       | パッケージを表示するかどうか
minClientVersion        | string                     | Ｘ       |
packageHash             | string                     | 可      | エンコードを使用して、パッケージのハッシュ[標準の base 64](https://tools.ietf.org/html/rfc4648#section-4)
packageHashAlgorithm    | string                     | 可      |
packageSize             | 整数                    | 可      | これは、.nupkg (バイト単位) パッケージのサイズ
projectUrl              | string                     | Ｘ       |
releaseNotes            | string                     | Ｘ       |
requireLicenseAgreement | boolean                    | Ｘ       | 想定`false`除外されている場合
概要                 | string                     | Ｘ       |
タグ                    | 文字列の配列           | Ｘ       |
タイトル                   | string                     | Ｘ       |
verbatimVersion         | string                     | Ｘ       | .Nuspec 内とバージョン文字列が見つかった最初

パッケージ`version`プロパティは、完全な正規化されたバージョン文字列。 意味 SemVer 2.0.0 ビルド データが含まれるここで。

`created`タイムスタンプは、パッケージはパッケージ ソースで一般的にこれは、カタログ アイテムのコミット タイムスタンプより前に、の短時間で最初に受信したときにします。

`packageHashAlgorithm`が生成するために使用するハッシュ アルゴリズムを表すサーバー実装によって定義されている文字列、`packageHash`です。 常に使用される nuget.org、`packageHashAlgorithm`値`SHA512`です。

`published`タイムスタンプは、パッケージが最後に示されている時点です。

> [!Note]
> Nuget.org、上、`published`値は、パッケージが一覧表示された場合 1900 年に設定します。

#### <a name="sample-request"></a>要求のサンプル

取得 https://api.nuget.org/v3/catalog0/data/2015.02.01.11.18.40/windowsazure.storage.1.0.0.json

#### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-package-details.json](./_data/catalog-package-details.json)]

### <a name="package-delete-catalog-items"></a>パッケージのカタログ項目を削除

カタログ アイテムの種類に`PackageDelete`ことを示すカタログ クライアントにパッケージがパッケージ ソースから削除されましたが不要になった (復元) などの任意のパッケージ操作で使用できる情報の最小限のセットが含まれています。

> [!Note]
> パッケージを削除して、同じパッケージ ID とバージョンを使用して後で再公開のことができます。 Nuget.org、これは非常にまれなケース パッケージ ID とバージョンが特定のパッケージ コンテンツに示されている公式のクライアントの前提が壊れたようです。 Nuget.org をパッケージの削除に関する詳細については、次を参照してください。 [、弊社のポリシー](../policies/deleting-packages.md)です。

パッケージのカタログ項目を削除にに加えて追加のプロパティがありますいない[カタログのすべてのリーフに含まれている](#catalog-leaf)です。

`version`プロパティはパッケージ .nuspec 内にある元のバージョン文字列。

`published`プロパティは、一般的にこれは、カタログ アイテムのコミット タイムスタンプより前に、の短い形式の時刻としてパッケージが削除された時間。

#### <a name="sample-request"></a>要求のサンプル

取得 https://api.nuget.org/v3/catalog0/data/2017.11.02.00.40.00/netstandard1.4_lib.1.0.0-test.json

#### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-package-delete.json](./_data/catalog-package-delete.json)]

## <a name="cursor"></a>カーソル

### <a name="overview"></a>概要

このセクションが、必ずしも必須ではないプロトコルでは、実用的なカタログ クライアント実装の一部にする必要のあるクライアントの概念について説明します。

クライアントを格納する必要があります、カタログは、時間によってインデックス設定される追加専用のデータ構造であるため、**カーソル**まで、どの時点でクライアントを表すが処理されるカタログ アイテムがローカルにします。 このカーソル値必要がありますしない生成されること、クライアントのコンピューター クロックを使用してに注意してください。 カタログ オブジェクトの元の値となる代わりに、`commitTimestamp`値。

たびに、クライアントがパッケージ ソースに新しいイベントを処理しようとすると、その必要がありますカタログのクエリのみ、コミット タイムスタンプのすべてのカタログ アイテムのストアド カーソルより大きい。 クライアントは、すべての新しいカタログ アイテムを適切に処理を後にだけその新しいカーソル値として処理されたカタログ アイテムの最新のコミット タイムスタンプを記録します。

このアプローチを使用して、クライアントはパッケージ ソースで発生したすべてのパッケージ イベントを受信しないことを確認できます。
さらに、クライアントは、カーソルの記録されたコミットのタイムスタンプより前の古いイベントを再処理することはありませんが。

このカーソルの強力な概念は、nuget.org のバック グラウンド ジョブの多くのために使用され、V3 API 自体を最新に保つために使用されます。 

### <a name="initial-value"></a>初期値

カタログのクライアントが非常に最初に開始 (とそのため、カーソルの値のない)、既定のカーソルの値を使用してください。NET の`System.DateTimeOffset.MinValue`または表現可能な最小のタイムスタンプのような類似概念です。

### <a name="iterating-over-catalog-items"></a>カタログ アイテムを反復処理します。

次のセットを処理するカタログ アイテムのクエリには、クライアントが必要です。

1. ローカル ストアから、カーソルが記録された値を取得します。
1. ダウンロードして、カタログのインデックスを逆シリアル化します。
1. すべてのカタログ、コミット タイムスタンプのページ検索*より大きい*カーソル。
1. 処理するカタログ アイテムの空のリストを宣言します。
1. カタログの各ページの手順 3. で一致します。
   1. ダウンロードしてカタログ ページを逆シリアル化します。
   1. すべてのカタログ、コミット タイムスタンプ アイテム検索*より大きい*カーソル。
   1. 手順 4 で宣言されているリストに一致するすべてのカタログ アイテムを追加します。
1. カタログ項目リストをコミット タイムスタンプ順に並べ替えます。
1. シーケンスの各カタログ アイテムを処理します。
   1. ダウンロードして、カタログ アイテムを逆シリアル化します。
   1. カタログ アイテムの型に適切に対処します。
   1. クライアントに固有の方法でカタログ アイテムのドキュメントを処理します。
1. 新しいカーソル値として、最後のカタログ アイテムのコミット タイムスタンプを記録します。

この基本的なアルゴリズムでは、クライアントの実装は、パッケージ ソースで使用可能なすべてのパッケージの完全なビューを構築できます。 クライアントでは、定期的に常に認識する、パッケージ ソースの最新の変更には、このアルゴリズムは実行のみ必要があります。

> [!Note]
> これは、アルゴリズムを使用してその nuget.org、[パッケージ メタデータ](registration-base-url-resource.md)、[パッケージ コンテンツの](package-base-address-resource.md)、[検索](search-query-service-resource.md)と[オートコンプリート](search-autocomplete-service-resource.md)リソースの最新の状態。

### <a name="dependent-cursors"></a>依存するカーソル

別のクライアントの出力に 1 つのクライアントの出力依存している固有の依存関係を持つ 2 つのカタログ クライアントがあるとします。 

#### <a name="example"></a>例

たとえばで nuget.org 新しく発行されたパッケージする必要がありますに反映されません検索リソース パッケージ メタデータ リソースに表示される前にします。 これは、公式の NuGet クライアントによって実行される「復元」操作は、パッケージ メタデータ リソースを使用するためです。 顧客は、search サービスを使用してパッケージを検出する場合は、パッケージ メタデータ リソースを使用してそのパッケージを正常に復元することが必要があります。 つまり、検索のリソースは、パッケージ メタデータ リソースに依存します。 各リソースには、そのリソースの更新カタログ クライアント バック グラウンド ジョブがあります。 各クライアントには独自のカーソル。

カタログ、更新プログラムの検索リソース カタログ クライアントのカーソルの両方のリソースが組み込まれているため*超える必要がありますいない*パッケージ メタデータ カタログ クライアントのカーソル。

#### <a name="algorithm"></a>アルゴリズム

この制限を実装するのに単に上記のアルゴリズムを変更します。

1. ローカル ストアから、カーソルが記録された値を取得します。
1. ダウンロードして、カタログのインデックスを逆シリアル化します。
1. すべてのカタログ、コミット タイムスタンプのページ検索*より大きい*カーソル**以下、依存関係のカーソル。**
1. 処理するカタログ アイテムの空のリストを宣言します。
1. カタログの各ページの手順 3. で一致します。
   1. ダウンロードしてカタログ ページを逆シリアル化します。
   1. すべてのカタログ、コミット タイムスタンプ アイテム検索*より大きい*カーソル**以下、依存関係のカーソル。**
   1. 手順 4 で宣言されているリストに一致するすべてのカタログ アイテムを追加します。
1. カタログ項目リストをコミット タイムスタンプ順に並べ替えます。
1. シーケンスの各カタログ アイテムを処理します。
   1. ダウンロードして、カタログ アイテムを逆シリアル化します。
   1. カタログ アイテムの型に適切に対処します。
   1. クライアントに固有の方法でカタログ アイテムのドキュメントを処理します。
1. 新しいカーソル値として、最後のカタログ アイテムのコミット タイムスタンプを記録します。

この変更のアルゴリズムを使用して、するシステムを構築できます依存カタログ クライアントの独自の特定のインデックス、成果物、その他をすべて作成します。
