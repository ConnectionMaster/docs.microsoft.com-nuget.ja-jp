---
title: カタログリソース、NuGet V3 API
description: カタログは、nuget.org で作成および削除されたすべてのパッケージのインデックスです。
author: joelverhagen
ms.author: jver
ms.date: 10/30/2017
ms.topic: reference
ms.reviewer: kraigb
ms.openlocfilehash: 6c04453fec9beb7b0998953384ec60694e1213c1
ms.sourcegitcommit: af059dc776cfdcbad20baab2919b5d6dc1e9022d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/09/2021
ms.locfileid: "99990138"
---
# <a name="catalog"></a>Catalog

**カタログ** は、作成や削除など、パッケージソースに対するすべてのパッケージ操作を記録するリソースです。 カタログリソースには、 `Catalog` [サービスインデックス](service-index.md)の型があります。 このリソースを使用して、公開され [ているすべてのパッケージを照会](../guides/api/query-for-all-published-packages.md)できます。

> [!Note]
> カタログは公式の NuGet クライアントによって使用されないため、すべてのパッケージソースがカタログを実装するわけではありません。

> [!Note]
> 現時点では、nuget.org カタログは中国では使用できません。 詳細については、「 [NuGet/NuGetGallery # 4949](https://github.com/NuGet/NuGetGallery/issues/4949)」を参照してください。

## <a name="versioning"></a>バージョン管理

次の `@type` 値が使用されます。

@type 値   | Notes
------------- | -----
Catalog/3.0.0 | 最初のリリース

## <a name="base-url"></a>ベース URL

次の Api のエントリポイント URL は、 `@id` 前述のリソース値に関連付けられているプロパティの値です `@type` 。 このトピックでは、プレースホルダー URL を使用 `{@id}` します。

## <a name="http-methods"></a>HTTP メソッド

カタログリソース内のすべての Url では、HTTP メソッドとのみがサポートされ `GET` `HEAD` ます。

## <a name="catalog-index"></a>カタログインデックス

カタログインデックスは、カタログアイテムのリストを時系列で並べた、既知の場所にあるドキュメントです。 これは、カタログリソースのエントリポイントです。

インデックスは、カタログページで構成されます。 各カタログページには、カタログアイテムが含まれています。 各カタログ項目は、特定の時点の1つのパッケージに関するイベントを表します。 カタログ項目は、パッケージソースから作成、一覧から削除、または一覧から削除されたパッケージを表すことができます。 カタログ項目を時間順に処理することにより、クライアントは、V3 パッケージソースに存在するすべてのパッケージの最新のビューを構築できます。

つまり、カタログ blob の階層構造は次のようになります。

- **Index**: カタログのエントリポイント。
- **Page**: カタログアイテムのグループ。
- **リーフ**: 1 つのパッケージの状態のスナップショットであるカタログアイテムを表すドキュメント。

各カタログオブジェクトには、項目が `commitTimeStamp` カタログに追加された日時を表すというプロパティがあります。 カタログアイテムは、コミットと呼ばれるバッチのカタログページに追加されます。 同じコミット内のすべてのカタログ項目が同じコミットタイムスタンプ ( `commitTimeStamp` ) とコミット ID () を持っている `commitId` 。 同じコミットに配置されたカタログ項目は、パッケージソースで同じ時点に発生したイベントを表します。 カタログのコミット内に順序がありません。

各パッケージの ID とバージョンは一意であるため、1つのコミットに複数のカタログアイテムを配置することはできません。 これにより、1つのパッケージのカタログアイテムをコミットタイムスタンプに対して常に明確に並べ替えることができます。

1つのカタログに対して複数のコミットを行うことはできません `commitTimeStamp` 。 言い換えると、は `commitId` と重複し `commitTimeStamp` ます。

パッケージ ID によってインデックスが作成される [パッケージメタデータリソース](registration-base-url-resource.md)とは異なり、カタログには時間によってのみインデックスが作成されます (クエリ可能)。

カタログアイテムは常に、単調に増加している順にカタログに追加されます。 これは、カタログのコミットが time X に追加されると、X 以下の時間でカタログのコミットが追加されないことを意味します。

次の要求では、カタログインデックスをフェッチします。

```
GET {@id}
```

カタログインデックスは、次のプロパティを持つオブジェクトを含む JSON ドキュメントです。

名前            | Type             | 必須 | Notes
--------------- | ---------------- | -------- | -----
commitId        | string           | はい      | 最新のコミットに関連付けられている一意の ID
commitTimeStamp | string           | はい      | 最新のコミットのタイムスタンプ
count           | 整数 (integer)          | はい      | インデックス内のページ数
items           | オブジェクトの配列 | はい      | オブジェクトの配列。各オブジェクトはページを表します。

配列の各要素 `items` は、各ページについて最小限の詳細を含むオブジェクトです。 これらのページオブジェクトには、カタログリーフ (items) は含まれません。 この配列内の要素の順序が定義されていません。 ページは、プロパティを使用して、メモリ内のクライアントによって並べ替えることができ `commitTimeStamp` ます。

新しいページが導入されると、が `count` インクリメントされ、新しいオブジェクトが配列に表示され `items` ます。

項目がカタログに追加されると、インデックスの `commitId` が変更され、が `commitTimeStamp` 増加します。 これら2つのプロパティは、基本的には `commitId` 、 `commitTimeStamp` 配列内のすべてのページと値の概要です `items` 。

### <a name="catalog-page-object-in-the-index"></a>インデックス内のカタログページオブジェクト

カタログインデックスのプロパティに存在するカタログページオブジェクトには `items` 、次のプロパティがあります。

名前            | Type    | 必須 | Notes
--------------- | ------- | -------- | -----
@id             | string  | はい      | [カタログをフェッチする URL] ページ
commitId        | string  | はい      | このページの最新のコミットに関連付けられている一意の ID
commitTimeStamp | string  | はい      | このページの最新のコミットのタイムスタンプ
count           | 整数 (integer) | はい      | [カタログ] ページの項目数

場合によっては、リーフがインデックスに残されることがある [パッケージメタデータリソース](registration-base-url-resource.md) とは対照的に、カタログリーフはインデックスにインライン化されず、常にページの URL を使用してフェッチされる必要があり `@id` ます。

### <a name="sample-request"></a>要求のサンプル

```
GET https://api.nuget.org/v3/catalog0/index.json
```

### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-index.json](./_data/catalog-index.json)]

## <a name="catalog-page"></a>[カタログ] ページ

[カタログ] ページは、カタログアイテムのコレクションです。 `@id`カタログインデックスで見つかった値のいずれかを使用してフェッチされたドキュメントです。 カタログページの URL は予測可能ではないため、カタログインデックスのみを使用して検出する必要があります。

新しいカタログ項目は、最大コミットタイムスタンプまたは新しいページに対してのみ、カタログインデックスのページに追加されます。 より高いコミットタイムスタンプを持つページがカタログに追加されると、古いページは追加または変更されません。

カタログページのドキュメントは、次のプロパティを持つ JSON オブジェクトです。

名前            | Type             | 必須 | Notes
--------------- | ---------------- | -------- | -----
commitId        | string           | はい      | このページの最新のコミットに関連付けられている一意の ID
commitTimeStamp | string           | はい      | このページの最新のコミットのタイムスタンプ
count           | 整数 (integer)          | はい      | ページ内の項目数
items           | オブジェクトの配列 | はい      | このページのカタログ項目
parent          | string           | はい      | カタログインデックスの URL

配列の各要素 `items` は、カタログ項目に関する詳細情報を含むオブジェクトです。 これらのアイテムオブジェクトには、カタログアイテムのすべてのデータが含まれていません。 ページの配列内の項目の順序が定義されて `items` いません。 項目は、プロパティを使用して、メモリ内のクライアントによって並べ替えることができ `commitTimeStamp` ます。

ページ内のカタログ項目の数は、サーバーの実装によって定義されます。 Nuget.org の場合、各ページには最大550個の項目がありますが、特定の時点での次のコミットバッチのサイズによっては、ページによって実際の数が小さくなることがあります。

新しい項目が導入されると、 `count` がインクリメントされ、新しいカタログ項目オブジェクトが配列に表示され `items` ます。

項目がページに追加されると、 `commitId` 変更とが `commitTimeStamp` 増加します。 これら2つのプロパティは、基本的に `commitId` 、 `commitTimeStamp` 配列内のすべての値と値の概要です `items` 。

### <a name="catalog-item-object-in-a-page"></a>ページ内のカタログアイテムオブジェクト

カタログページのプロパティに存在するカタログアイテムオブジェクトには、 `items` 次のプロパティがあります。

名前            | Type    | 必須 | Notes
--------------- | ------- | -------- | -----
@id             | string  | はい      | カタログアイテムを取得するための URL
@type           | string  | はい      | カタログアイテムの種類
commitId        | string  | はい      | このカタログアイテムに関連付けられているコミット ID
commitTimeStamp | string  | はい      | このカタログ項目のコミットタイムスタンプ
nuget: id        | string  | はい      | このリーフが関連付けられているパッケージ ID
nuget: バージョン   | string  | はい      | このリーフが関連付けられているパッケージのバージョン

値は、 `@type` 次の2つの値のいずれかになります。

1. `nuget:PackageDetails`: これ `PackageDetails` は、カタログリーフドキュメントの型に対応します。
1. `nuget:PackageDelete`: これは `PackageDelete` 、カタログリーフドキュメント内の型に対応します。

各型の意味の詳細については、以下の [対応する項目の種類](#item-types) を参照してください。

### <a name="sample-request"></a>要求のサンプル

```
GET https://api.nuget.org/v3/catalog0/page2926.json
```

### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-page.json](./_data/catalog-page.json)]

## <a name="catalog-leaf"></a>カタログリーフ

カタログリーフには、特定の時点での特定のパッケージ ID とバージョンに関するメタデータが含まれます。 これは、カタログページの値を使用してフェッチされたドキュメントです `@id` 。 カタログリーフの URL は予測可能ではないため、カタログページのみを使用して検出する必要があります。

カタログリーフドキュメントは、次のプロパティを持つ JSON オブジェクトです。

名前                    | Type                       | 必須 | Notes
----------------------- | -------------------------- | -------- | -----
@type                   | 文字列または文字列の配列 | はい      | カタログアイテムの種類です。
カタログ: commitId        | string                     | はい      | このカタログアイテムに関連付けられているコミット ID
catalog: commitTimeStamp | string                     | はい      | このカタログ項目のコミットタイムスタンプ
id                      | string                     | はい      | カタログアイテムのパッケージ ID
published               | string                     | はい      | パッケージカタログアイテムの公開日
version                 | string                     | はい      | カタログアイテムのパッケージバージョン

### <a name="item-types"></a>項目の種類

プロパティは、 `@type` 文字列または文字列の配列です。 便宜上、値が文字列の場合は、 `@type` サイズが1の任意の配列として処理する必要があります。 に使用できるすべての値が記載されているわけではありません `@type` 。 ただし、各カタログアイテムには、次の2つの文字列型の値のうち1つだけが含まれます。

1. `PackageDetails`: パッケージメタデータのスナップショットを表します。
1. `PackageDelete`: 削除されたパッケージを表します。

### <a name="package-details-catalog-items"></a>パッケージの詳細カタログ項目

種類がのカタログアイテムには、 `PackageDetails` 特定のパッケージ (ID とバージョンの組み合わせ) のパッケージメタデータのスナップショットが含まれます。 パッケージの詳細カタログ項目は、パッケージソースが次のいずれかのシナリオに遭遇したときに生成されます。

1. パッケージが **プッシュ** されます。
1. パッケージが **一覧表示** されます。
1. パッケージが **一覧** から削除されます。
1. パッケージが **折り返し** されます。

パッケージのリフロー処理は、基本的に、パッケージ自体を変更せずに既存のパッケージの偽のプッシュを生成する管理用のジェスチャです。 Nuget.org では、カタログを使用するバックグラウンドジョブの1つでバグを修正した後に、リフロー処理が使用されます。

カタログ項目を使用しているクライアントは、どのシナリオでカタログ項目が生成されたかを判断することはできません。 代わりに、クライアントは、管理されたビューまたはインデックスを、カタログアイテムに含まれるメタデータで更新するだけです。 さらに、重複または冗長なカタログアイテムは、適切に処理する必要があります (冪等)。

パッケージの詳細カタログアイテムには、 [すべてのカタログリーフに含まれる](#catalog-leaf)ものに加えて、次のプロパティがあります。

名前                    | Type                       | 必須 | Notes
----------------------- | -------------------------- | -------- | -----
作成者                 | string                     | no       |
created                 | string                     | no       | パッケージが最初に作成されたときのタイムスタンプ。 フォールバックプロパティ: `published` 。
dependencyGroups        | オブジェクトの配列           | no       | ターゲットフレームワーク ([パッケージメタデータリソースと同じ形式](registration-base-url-resource.md#package-dependency-group)) でグループ化されたパッケージの依存関係
今後             | object                     | no       | パッケージに関連付けられている非推奨 ([パッケージメタデータリソースと同じ形式](registration-base-url-resource.md#package-deprecation))
description             | string                     | no       |
iconUrl                 | string                     | no       |
isPrerelease            | boolean                    | no       | パッケージのバージョンがプレリリースであるかどうか。 はから検出でき `version` ます。
language                | string                     | no       |
licenseUrl              | string                     | no       |
一覧                  | boolean                    | no       | パッケージが一覧表示されているかどうか
minClientVersion        | string                     | no       |
packageHash             | string                     | はい      | パッケージのハッシュ、[標準ベース 64](https://tools.ietf.org/html/rfc4648#section-4)を使用したエンコード
packageHashAlgorithm    | string                     | はい      |
パッケージのパッケージ             | 整数 (integer)                    | はい      | パッケージのサイズ。 nupkg (バイト単位)
packageTypes            | オブジェクトの配列           | no       | 作成者によって指定されたパッケージの種類。
projectUrl              | string                     | no       |
releaseNotes            | string                     | no       |
requireLicenseAgreement | boolean                    | no       | `false`除外するかどうかを仮定
まとめ                 | string                     | no       |
tags                    | 文字列の配列           | no       |
title                   | string                     | no       |
verbatimVersion         | string                     | no       | 最初に見つかったバージョン文字列は. nuspec にあります。
脆弱性         | オブジェクトの配列           | no       | パッケージのセキュリティの脆弱性

パッケージ `version` プロパティは、正規化後の完全なバージョン文字列です。 これは、ここに SemVer 2.0.0 build データを含めることができることを意味します。

`created`タイムスタンプとは、パッケージソースが最初にパッケージを受信したときのことです。通常は、カタログアイテムのコミットタイムスタンプよりも短い時間です。

は `packageHashAlgorithm` 、の生成に使用されるハッシュアルゴリズムを表すサーバー実装によって定義される文字列です `packageHash` 。 nuget.org は、常にの値を使用し `packageHashAlgorithm` `SHA512` ます。

プロパティは、 `packageTypes` パッケージの種類が作成者によって指定された場合にのみ存在します。 存在する場合は、常に1つ以上のエントリが含まれます。 配列内の各項目 `packageTypes` は、次のプロパティを持つ JSON オブジェクトです。

名前      | Type    | 必須 | Notes
--------- | ------- | -------- | -----
name      | string  | はい      | パッケージの種類の名前。
version    | string  | no       | パッケージの種類のバージョンです。 作成者が明示的に nuspec 内のバージョンを指定した場合にのみ存在します。

`published`タイムスタンプは、パッケージが最後に表示された時刻です。

> [!Note]
> Nuget.org の場合、 `published` パッケージが一覧から削除されると、値は1900年に設定されます。

#### <a name="vulnerabilities"></a>脆弱性

`vulnerability` オブジェクトの配列。 各脆弱性には、次のプロパティがあります。

名前         | Type   | 必須 | Notes
------------ | ------ | -------- | -----
advisoryUrl  | string | はい      | パッケージのセキュリティアドバイザリの場所
severity     | string | はい      | アドバイザリの重大度: "0" = 低、"1" = 中程度、"2" = 高、"3" = 重大

ここに記載されている以外 `severity` の値がプロパティに含まれている場合、アドバイザリの重大度は低いと見なされます。

#### <a name="sample-request"></a>要求のサンプル

```
GET https://api.nuget.org/v3/catalog0/data/2015.02.01.11.18.40/windowsazure.storage.1.0.0.json
```

#### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-package-details.json](./_data/catalog-package-details.json)]

### <a name="package-delete-catalog-items"></a>カタログアイテムの削除のパッケージ化

この種類のカタログアイテムには、パッケージ `PackageDelete` がパッケージソースから削除され、どのパッケージ操作でも利用できなくなったことをカタログクライアントに示す最小限の情報セットが含まれています (復元など)。

> [!NOTE]
> パッケージが削除され、後から同じパッケージ ID とバージョンを使用して再発行される可能性があります。 Nuget.org では、これは非常にまれなケースです。これは、パッケージ ID とバージョンが特定のパッケージコンテンツを暗示しているという公式のクライアントの前提が壊れるためです。 Nuget.org でのパッケージ削除の詳細については、 [ポリシー](../nuget-org/policies/deleting-packages.md)を参照してください。

パッケージの削除カタログアイテムには、 [すべてのカタログリーフに含まれる](#catalog-leaf)ものに加えて、追加のプロパティはありません。

`version`プロパティは、nuspec で見つかった元のバージョン文字列です。

プロパティは、 `published` パッケージが削除された時刻です。通常は、カタログアイテムのコミットタイムスタンプよりも短い時間です。

#### <a name="sample-request"></a>要求のサンプル

```
GET https://api.nuget.org/v3/catalog0/data/2017.11.02.00.40.00/netstandard1.4_lib.1.0.0-test.json
```

#### <a name="sample-response"></a>応答のサンプル

[!code-JSON [catalog-package-delete.json](./_data/catalog-package-delete.json)]

## <a name="cursor"></a>カーソル

### <a name="overview"></a>概要

このセクションでは、クライアントの概念について説明します。ただし、必ずしもプロトコルによって義務付けられるわけではありませんが、実用的なカタログクライアントの実装に含まれる必要があります。

カタログは、時間によってインデックス付けされた追加専用のデータ構造であるため、クライアントがカタログ項目を処理した時点を表すローカルの **カーソル** をローカルに格納する必要があります。 このカーソル値は、クライアントのコンピュータークロックを使用して生成することはできません。 代わりに、値はカタログオブジェクトの値から取得する必要があり `commitTimestamp` ます。

クライアントは、パッケージソースの新しいイベントを処理するたびに、格納されているカーソルよりも高いコミットタイムスタンプを持つすべてのカタログアイテムのカタログに対してのみクエリを実行する必要があります。 クライアントは、すべての新しいカタログアイテムを正常に処理した後、新しいカーソル値として処理されたばかりのカタログアイテムの最新のコミットタイムスタンプを記録します。

この方法を使用すると、クライアントは、パッケージソースで発生したパッケージイベントを見逃さないようにすることができます。
また、クライアントは、カーソルの記録されたコミットタイムスタンプの前に古いイベントを再処理する必要がありません。

このようなカーソルの強力な概念は、多くの nuget.org バックグラウンドジョブで使用され、V3 API 自体を最新の状態に保つために使用されます。 

### <a name="initial-value"></a>初期値

カタログクライアントが初めて起動したとき (つまり、カーソル値がない場合) は、の既定のカーソル値を使用する必要があります。 `System.DateTimeOffset.MinValue` または、表現可能な最小のタイムスタンプと同様の概念です。

### <a name="iterating-over-catalog-items"></a>カタログアイテムの反復処理

処理する次のカタログ項目のセットを照会するには、クライアントは次のことを行う必要があります。

1. ローカルストアから記録されたカーソル値を取得します。
1. カタログインデックスをダウンロードして逆シリアル化します。
1. コミットタイムスタンプがカーソル *より大きい* すべてのカタログページを検索します。
1. 処理するカタログアイテムの空のリストを宣言します。
1. 手順3で一致した各カタログページ:
   1. カタログページをダウンロードし、逆シリアル化します。
   1. コミットタイムスタンプがカーソル *より大きい* すべてのカタログアイテムを検索します。
   1. 一致するすべてのカタログ項目を、手順 4. で宣言したリストに追加します。
1. コミットタイムスタンプを使って、カタログアイテムの一覧を並べ替えます。
1. 各カタログ項目を順番に処理します。
   1. カタログ項目をダウンロードして逆シリアル化します。
   1. カタログ項目の種類に適切に対応します。
   1. クライアント固有の方法でカタログ項目ドキュメントを処理します。
1. 最後のカタログ項目のコミットタイムスタンプを新しいカーソル値として記録します。

この基本アルゴリズムを使用すると、クライアント実装は、パッケージソースで使用可能なすべてのパッケージの完全なビューを構築できます。 クライアントは、パッケージソースに対する最新の変更を常に認識するために、このアルゴリズムを定期的に実行する必要があります。

> [!Note]
> これは、nuget.org が [パッケージメタデータ](registration-base-url-resource.md)、 [パッケージコンテンツ](package-base-address-resource.md)、 [検索](search-query-service-resource.md) 、および [オートコンプリート](search-autocomplete-service-resource.md) リソースを最新の状態に保つために使用するアルゴリズムです。

### <a name="dependent-cursors"></a>依存カーソル

1つのクライアントの出力が別のクライアントの出力に依存する、固有の依存関係を持つ2つのカタログクライアントがあるとします。 

#### <a name="example"></a>例

たとえば、nuget.org では、新しく発行されたパッケージは、パッケージメタデータリソースに表示される前に、検索リソースに表示されません。 これは、公式の NuGet クライアントによって実行される "復元" 操作によってパッケージメタデータリソースが使用されるためです。 顧客が search サービスを使用してパッケージを検出した場合、パッケージメタデータリソースを使用してパッケージを正常に復元できる必要があります。 つまり、検索リソースは、パッケージメタデータリソースに依存します。 各リソースには、そのリソースを更新するカタログクライアントのバックグラウンドジョブがあります。 各クライアントには専用のカーソルがあります。

両方のリソースがカタログから構築されるため、検索リソースを更新するカタログクライアントのカーソルは、パッケージメタデータカタログクライアントのカーソルを越えることは *できません* 。

#### <a name="algorithm"></a>アルゴリズム

この制限を実装するには、上記のアルゴリズムを次のように変更するだけです。

1. ローカルストアから記録されたカーソル値を取得します。
1. カタログインデックスをダウンロードして逆シリアル化します。
1. **依存関係のカーソル** 以下のカーソル *よりも大きい* コミットタイムスタンプを持つすべてのカタログページを検索します。
1. 処理するカタログアイテムの空のリストを宣言します。
1. 手順3で一致した各カタログページ:
   1. カタログページをダウンロードし、逆シリアル化します。
   1. **依存関係のカーソルよりも小さいか等しい** カーソル *よりも大きい* コミットタイムスタンプを持つすべてのカタログアイテムを検索します。
   1. 一致するすべてのカタログ項目を、手順 4. で宣言したリストに追加します。
1. コミットタイムスタンプを使って、カタログアイテムの一覧を並べ替えます。
1. 各カタログ項目を順番に処理します。
   1. カタログ項目をダウンロードして逆シリアル化します。
   1. カタログ項目の種類に適切に対応します。
   1. クライアント固有の方法でカタログ項目ドキュメントを処理します。
1. 最後のカタログ項目のコミットタイムスタンプを新しいカーソル値として記録します。

この変更されたアルゴリズムを使用して、依存するカタログクライアントのシステムを構築して、独自のインデックス、アーティファクトなどを生成することができます。
